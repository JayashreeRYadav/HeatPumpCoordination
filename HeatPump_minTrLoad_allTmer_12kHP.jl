## obj fun - minimize Tr loading, cosidering all transformers, smart HP, VFD operated
##18kHP

# import Pkg
# Pkg.add("Interpolations")

using JuMP
using Ipopt
using Gurobi
using Plots
using LaTeXStrings
using MAT
using DataFrames
using Dates
using Interpolations

Shungnak_HouseParameters = matread("Shungnak_ETP_parameters.mat")
# Shungnak_HouseParameters = matread("Shungnak_ETP_18thTmer.mat")
# transformers_data = Shungnak_HouseParameters["Shungnak_HouseParameters_Tmer18"]
transformers_data = Shungnak_HouseParameters["Shungnak_HouseParameters_updated"]
transformers = length(transformers_data["Txmer"])
N_array = [transformers_data["Txmer"][i]["houses"] for i in 1:transformers]
Pmax_array = [transformers_data["Txmer"][i]["T_KVA"] for i in 1:transformers]
Dmax_array = [transformers_data["Txmer"][i]["Dmax"] for i in 1:transformers]
Ua_array = [transformers_data["Txmer"][i]["Ua"] for i in 1:transformers]
Ca_array = [transformers_data["Txmer"][i]["Ca"] for i in 1:transformers]
Hm_array = [transformers_data["Txmer"][i]["Hm"] for i in 1:transformers]
Cm_array = [transformers_data["Txmer"][i]["Cm"] for i in 1:transformers]
Shungnak_2023_temp = matread("Shungnak_temp_historicData_Julia.mat")  # -15 outside temperature
COP = Shungnak_2023_temp["COP"];
Demand_data = matread("Shungnak_loadData.mat");

# T_a = matread("HP_18kHP_d1tod118_smart_avgTempConstraint.mat")["Ta"][118]
Pg = 1000  # max generation capacity
T = 12*24 # Total time steps
dt = 1/12  # 5 minutes
# D = Shungnak_HouseParameters["D2_5min"][1:T]
# PV = Shungnak_HouseParameters["PV_5min"][1:T];

# COP = 2.1  # Coefficient of Performance
Tset = 19  # set temperature
epsilon = 1
Tmin = 16#15.60  # minimum temperature
Tmax = 22  # maximum temperature
Pth = 5.3; # kW max thermal power of a heat pump
Ph_el_max = 2.1;#4.14#Pth/2.1; # kW max electric power of a heat pump [1.9 - kW 12k BTU]/h LG HP, 
Ph_el_min = 0; # kW min electric power of a heat pump
P_oil_max = 0.8*138500*0.000293*0.3
# π_int = 0.5; # internal gains
# ζ_int = 0.25; # internal gains
# IntT = 0; # internal temperature
# SolT = 0.005; # solar temperature
# E_hp_max = 5.28/12; # max energy of heat pump
# E_hp_min = 0; # min energy of heat pump
# global k = 1;

Ph_el_matrix = []
Ta_matrix = []
Tm_matrix = []
D_matrix = []
S_matrix = []

for d in 1:365

    Tout = Shungnak_2023_temp["Shungnak_temp_array"][:, d];

    min = 0:60:24*60;
    min_new = 0:dt*60:24*60-dt*60;
    interp_func = linear_interpolation(min, Tout);
    interp_cop = linear_interpolation(COP[:,2], COP[:,3]);
    Tout_interp = interp_func.(min_new);
    Demand = Demand_data["Shungnak_daily_data"][d][:,1];#/max(maximum(Demand_data["Shungnak_daily_data"][d][:,1]), 1e-6);
    PV_10min = Demand_data["Shungnak_daily_data"][d][:,4];
    num = length(Demand);
    interp_demand = linear_interpolation(0:10:(num-1)*10, Demand, extrapolation_bc=Line());
    interp_PV = linear_interpolation(0:10:(num-1)*10, PV_10min, extrapolation_bc=Line());
    D = interp_demand.(min_new);
    PV = interp_PV.(min_new);

    m = Model(Gurobi.Optimizer);
    P_el = []  # Electric power of heat pump
    P_oil = []  # Thermal power generated by oil heater
    Ta = []  # Temperature
    Tm = []  # Mass temperature
    z = []  # Binary variable
    S = []  # Slack variable.

    if d == 1
        T_ini = [3 * rand(Int(N_array[i])) .+ 18 for i in 1:transformers];
    #    T_ini = [value.(Ta_matrix[171][i][:, T+1]) for i in 1:transformers]; #[T_a[i][:,end] for i in 1:transformers];
   end

    if minimum(Tout) < -10#23.33
        # # if d ==1
        # #     T_ini = [3 * rand(Int(N_array[i])) .+ 18 for i in 1:transformers]
        # # end
        # # println("Day $d: Temperature below -23°C, turning off heat pumps.")
        P_el1 = [zeros(Int(N_array[i]), T) for i in 1:transformers]
        D1 = [D*Int(N_array[i])/116 for i in 1:transformers]
        S = [1.1*maximum(D)*Int(N_array[i])/116 for i in 1:transformers]
        # # Ta = [zeros(Int(N_array[i]), T) for i in 1:transformers]
        # # Tm = [zeros(Int(N_array[i]), T) for i in 1:transformers]
        # push!(S, @variable(m)) # Slack variable
        for i in 1:transformers
            N = Int(N_array[i])
            Pmax = 60 #Pmax_array[i]
            Dmax = Dmax_array[i]
            Ua = Ua_array[i]/2.5
            Ca = Ca_array[i]*2.5
            Hm = Hm_array[i]/2.5
            Cm = Cm_array[i]*2.5
            # push!(P_el, @variable(m, [1:N, 1:T]))  # Electric power of heat pump
            push!(P_oil, @variable(m, [1:N, 1:T]))  # Thermal power generated by oil heater
            push!(Ta, @variable(m, [1:N, 1:T+1]))  # Temperature
            push!(Tm, @variable(m, [1:N, 1:T+1]))  # Mass temperature
            
            # Define the temperature and thermal mass equations with oil heating
            for n in 1:N
                # Oil heating should kick in when Tout < -23°C
                # @constraint(m, P_el[end][n, :] == 0)  # Heat pump is off
                @constraint(m, 0 .<= P_oil[end][n, :] .<= P_oil_max)  # Oil heater is on
                @constraint(m, Ta[end][n, 1] == T_ini[i][n, 1])  # Initial air temperature
                @constraint(m, Tm[end][n, 1] == T_ini[i][n, 1])  # Initial mass temperature
                @constraint(m, Tmin .<= Ta[end][n, :] .<= Tmax)
    
                for t in 1:T
                    # Update temperature equations using oil heating
                    @constraint(m, Ta[end][n, t+1] == Ta[end][n, t] + dt / Ca[n] * (Tm[end][n, t] * Hm[n] - (Ua[n] + Hm[n]) * Ta[end][n, t] + Tout_interp[t] * Ua[n] + P_oil[end][n, t]))  
                    @constraint(m, Tm[end][n, t+1] == Tm[end][n, t] + dt / Cm[n] * (Hm[n] * (Ta[end][n, t] - Tm[end][n, t])))
                    @constraint(m, 18 <= sum(Ta[end][n, :]) / T <= 20) 
                end
            end
        end
        # minimize!(m)
        optimize!(m)
        push!(Ph_el_matrix, P_el1)
        push!(Ta_matrix, [value.(Ta[i]) for i in 1:transformers])
        push!(Tm_matrix, [value.(Tm[i]) for i in 1:transformers])
        push!(D_matrix, D1)
        push!(S_matrix, S)
        T_ini = [value.(Ta_matrix[end][i][:, T+1]) for i in 1:transformers]
        continue
    end
   

    for i in 1:transformers
        N = Int(N_array[i])
        Pmax = 60#Pmax_array[i]
        Dmax = Dmax_array[i]
        Ua = Ua_array[i]/2.5
        Ca = Ca_array[i]*2.5
        Hm = Hm_array[i]/2.5
        Cm = Cm_array[i]*2.5
        push!(P_el, @variable(m, [1:N, 1:T]))  # Electric power of heat pump
        push!(P_oil, @variable(m, [1:N, 1:T]))  # Thermal power generated by oil heater
        push!(Ta, @variable(m, [1:N, 1:T+1]))  # Temperature
        push!(Tm, @variable(m, [1:N, 1:T+1]))  # Mass temperature
        push!(z, @variable(m, [1:N, 1:T], Bin))  # Binary variable
        push!(S, @variable(m)) # Slack variable

        # @constraint(m, [t = 1:T], D[t]*N/116 + sum(P_el[end][n, t] for n = 1:N) <= Pmax)
        @constraint(m, [t = 1:T], D[t]*N/116 + sum(P_el[end][n, t] for n = 1:N) <= S[i])
        # @constraint(m, cc[t = 1:T], D[t]*Dmax + sum(E_hp[n, t]/dt for n = 1:N) <= Pmax)
        # @constraint(m, cc1[t = 1:T], D[t]*Dmax + sum(E_hp[n, t]/dt for n = 1:N) <= S)
        # @constraint(m, 0 .<= z .<= 1)

        for n in 1:N
            @constraint(m, Ph_el_min .<= P_el[end][n, :] .<= Ph_el_max)
            # @constraint(m, E_hp_min .<= E_hp[n, :] .<= E_hp_max)
            @constraint(m, 0 .<= P_oil[end][n, :] .<= P_oil_max)
            @constraint(m, Tmin .<= Ta[end][n, :] .<= Tmax)
            @constraint(m, Ta[end][n, 1] == T_ini[i][n,1])  # initial air temperature
            @constraint(m, Tm[end][n, 1] == T_ini[i][n,1])  # initial mass temperature
            for t in 1:T
                # if Tout_interp[t] <= -23#-12
                    # @constraint(m, Ta[end][n, t+1] == Ta[end][n, t] + dt / Ca[n] * (Tm[end][n, t] * Hm[n] - (Ua[n] + Hm[n]) * Ta[end][n, t] + Tout_interp[t] * Ua[n] + P_oil[end][n, t]))
                    # @constraint(m, Tm[end][n, t+1] == Tm[end][n, t] + dt / Cm[n] * (Hm[n] * (Ta[end][n, t] - Tm[end][n, t])))
                    # # @constraint(m, 17 <= sum(Ta[end][n, :]) / T <= 21) 
                    # @constraint(m, P_el[end][n, t] == 0)
                if Tout_interp[t] <= Tmin
                    @constraint(m, Ta[end][n, t+1] == Ta[end][n, t] + dt / Ca[n] * (Tm[end][n, t] * Hm[n] - (Ua[n] + Hm[n]) * Ta[end][n, t] + Tout_interp[t] * Ua[n] + P_el[end][n, t] * interp_cop(Tout_interp[t])))
                    @constraint(m, Tm[end][n, t+1] == Tm[end][n, t] + dt / Cm[n] * (Hm[n] * (Ta[end][n, t] - Tm[end][n, t])))
                    # @constraint(m, P_el[n, t] == z[n, t] * Ph_el_max)
                    # @constraint(m, Ta[n, t+1] == Ta[n, t] + 1 / Ca[n] * (E_hp[n, t] * COP + (1-π_int)*IntT + (1-ζ_int)*SolT  - (Ta[n, t] - Tout) * dt * Ua[n]))
                    @constraint(m, 19 <= sum(Ta[end][n, :]) / T <= 22) # average temperature constraint
                elseif Tout_interp[t] > Tmax
                    @constraint(m, Ta[end][n, t+1] == Ta[end][n, t] + dt / Ca[n] * (Tm[end][n, t] * Hm[n] - (Ua[n] + Hm[n]) * Ta[end][n, t] + Tout_interp[t] * Ua[n] - 0.8* P_el[end][n, t] * interp_cop(Tout_interp[t])))
                    @constraint(m, Tm[end][n, t+1] == Tm[end][n, t] + dt / Cm[n] * (Hm[n] * (Ta[end][n, t] - Tm[end][n, t])))
                    @constraint(m, 18 <= sum(Ta[end][n, :]) / T <= 20) # average temperature constraint
                else 
                    # @constraint(m, P_el[end][n, t] == 0)
                    @constraint(m, Ta[end][n, t+1] == Ta[end][n, t] + dt / Ca[n] * (Tm[end][n, t] * Hm[n] - (Ua[n] + Hm[n]) * Ta[end][n, t] + Tout_interp[t] * Ua[n] + P_el[end][n, t] * interp_cop(Tout_interp[t])))
                    @constraint(m, Tm[end][n, t+1] == Tm[end][n, t] + dt / Cm[n] * (Hm[n] * (Ta[end][n, t] - Tm[end][n, t])))
                    @constraint(m, 19 <= sum(Ta[end][n, :]) / T <= 22) 
                end
            end
            # @constraint(m, sum((-Ta[n, :] .+ Tset)) <= epsilon)
            
        end
        # @objective(m, Min, S[i])

    end

    # constraint for the total generation capacity
    # total_power = 0
    for t=1:T
        # @constraint(m, (sum(Dmax_array * D[t] ) + sum(P_el[i][n, t] for n in 1:N)) <= Pg+PV[t])
        total_power = 0
        for i in 1:transformers
            N = Int(N_array[i])
            total_power += N/116 * D[t] + sum(P_el[i][n, t] for n in 1:N)
        end
        @constraint(m, total_power <= Pg+PV[t])
    end
    # @objective(m, Min, sum(P_el[i][n, t] for  i in 1:transformers, n in 1:Int(N_array[i]), t in 1:T))
    @objective(m, Min, S)

    # optimize!(m)
    JuMP.optimize!(m)
    termination_status = JuMP.termination_status(m)
    primal_status = JuMP.primal_status(m)
    println("Termination status: ", termination_status)


    ObjValue = objective_value(m)

    # Store results in matrices
    push!(Ta_matrix, [value.(Ta[i]) for i in 1:transformers])
    push!(Tm_matrix, [value.(Tm[i]) for i in 1:transformers])
    push!(Ph_el_matrix, [value.(P_el[i]) for i in 1:transformers])
    # push!(P_oil_matrix, [value.(P_oil[i]) for i in 1:transformers])
    push!(D_matrix, [D*Int(N_array[i])/116 for i in 1:transformers])
    push!(S_matrix, value.(S))
    T_ini = [value.(Ta_matrix[end][i][:, T+1]) for i in 1:transformers]
end
# filename = "HP_18kHP_smart_avgTempConstraint.mat"
# matwrite(filename, Dict("Ph_el" => Ph_el_matrix, "Ta" => Ta_matrix, "Tm" => Tm_matrix, "D" => D_matrix, "Tmer_Loadings" => S_matrix))
# matwrite(filename, Dict("E_hp" => value.(E_hp), "Ta" => value.(Ta), "Tm" => value.(Tm), "D" => D*Dmax))